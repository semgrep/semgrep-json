(* Generated by ocaml-tree-sitter. *)

(*
   Disable warning 42:
     "this use of Foo relies on type-directed disambiguation,
     it will not compile with OCaml 4.00 or earlier."
*)
[@@@warning "-42"]

(* Disable warnings against unused variables. *)
[@@@warning "-26-27-32"]

open Tree_sitter_bindings
open Tree_sitter_run

type mt = Run.matcher_token

external create_parser :
  unit -> Tree_sitter_API.ts_parser = "octs_create_parser_json"

let parse_source_string ?src_file contents =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_string ?src_file ts_parser contents

let parse_source_file src_file =
  let ts_parser = create_parser () in
  Tree_sitter_parsing.parse_source_file ts_parser src_file

let extras = [
  "comment";
]

let children_regexps : (string * Run.exp option) list = [
  "false", None;
  "string_content_", None;
  "semgrep_ellipsis", None;
  "comment", None;
  "escape_sequence", None;
  "semgrep_metavariable", None;
  "true", None;
  "null", None;
  "identifier", None;
  "number", None;
  "string_content",
  Some (
    Repeat1 (
      Alt [|
        Token (Name "string_content_");
        Token (Name "escape_sequence");
      |];
    );
  );
  "string",
  Some (
    Alt [|
      Alt [|
        Seq [
          Token (Literal "\"");
          Token (Literal "\"");
        ];
        Seq [
          Token (Literal "\"");
          Token (Name "string_content");
          Token (Literal "\"");
        ];
      |];
      Token (Name "semgrep_metavariable");
      Token (Name "identifier");
    |];
  );
  "array",
  Some (
    Seq [
      Token (Literal "[");
      Opt (
        Seq [
          Token (Name "value");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "value");
            ];
          );
        ];
      );
      Token (Literal "]");
    ];
  );
  "object",
  Some (
    Seq [
      Token (Literal "{");
      Opt (
        Seq [
          Token (Name "pair");
          Repeat (
            Seq [
              Token (Literal ",");
              Token (Name "pair");
            ];
          );
        ];
      );
      Opt (
        Token (Literal ",");
      );
      Token (Literal "}");
    ];
  );
  "pair",
  Some (
    Alt [|
      Seq [
        Token (Name "string");
        Token (Literal ":");
        Token (Name "value");
      ];
      Seq [
        Token (Name "semgrep_ellipsis");
      ];
    |];
  );
  "value",
  Some (
    Alt [|
      Alt [|
        Token (Name "object");
        Token (Name "array");
        Token (Name "number");
        Token (Name "string");
        Token (Name "true");
        Token (Name "false");
        Token (Name "null");
      |];
      Token (Name "semgrep_ellipsis");
    |];
  );
  "document",
  Some (
    Alt [|
      Repeat (
        Token (Name "value");
      );
      Seq [
        Token (Name "pair");
        Opt (
          Token (Literal ",");
        );
      ];
    |];
  );
]

let trans_false_ ((kind, body) : mt) : CST.false_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_content_ ((kind, body) : mt) : CST.string_content_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_ellipsis ((kind, body) : mt) : CST.semgrep_ellipsis =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_comment ((kind, body) : mt) : CST.comment =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_escape_sequence ((kind, body) : mt) : CST.escape_sequence =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_semgrep_metavariable ((kind, body) : mt) : CST.semgrep_metavariable =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_true_ ((kind, body) : mt) : CST.true_ =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_null ((kind, body) : mt) : CST.null =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_identifier ((kind, body) : mt) : CST.identifier =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_number ((kind, body) : mt) : CST.number =
  match body with
  | Leaf v -> v
  | Children _ -> assert false

let trans_string_content ((kind, body) : mt) : CST.string_content =
  match body with
  | Children v ->
      Run.repeat1
        (fun v ->
          (match v with
          | Alt (0, v) ->
              `Str_content_ (
                trans_string_content_ (Run.matcher_token v)
              )
          | Alt (1, v) ->
              `Esc_seq (
                trans_escape_sequence (Run.matcher_token v)
              )
          | _ -> assert false
          )
        )
        v
  | Leaf _ -> assert false

let trans_string_ ((kind, body) : mt) : CST.string_ =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_DQUOT_DQUOT (
            (match v with
            | Alt (0, v) ->
                `DQUOT_DQUOT (
                  (match v with
                  | Seq [v0; v1] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        Run.trans_token (Run.matcher_token v1)
                      )
                  | _ -> assert false
                  )
                )
            | Alt (1, v) ->
                `DQUOT_str_content_DQUOT (
                  (match v with
                  | Seq [v0; v1; v2] ->
                      (
                        Run.trans_token (Run.matcher_token v0),
                        trans_string_content (Run.matcher_token v1),
                        Run.trans_token (Run.matcher_token v2)
                      )
                  | _ -> assert false
                  )
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_meta (
            trans_semgrep_metavariable (Run.matcher_token v)
          )
      | Alt (2, v) ->
          `Id (
            trans_identifier (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let rec trans_array_ ((kind, body) : mt) : CST.array_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_value (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_value (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.trans_token (Run.matcher_token v2)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_object_ ((kind, body) : mt) : CST.object_ =
  match body with
  | Children v ->
      (match v with
      | Seq [v0; v1; v2; v3] ->
          (
            Run.trans_token (Run.matcher_token v0),
            Run.opt
              (fun v ->
                (match v with
                | Seq [v0; v1] ->
                    (
                      trans_pair (Run.matcher_token v0),
                      Run.repeat
                        (fun v ->
                          (match v with
                          | Seq [v0; v1] ->
                              (
                                Run.trans_token (Run.matcher_token v0),
                                trans_pair (Run.matcher_token v1)
                              )
                          | _ -> assert false
                          )
                        )
                        v1
                    )
                | _ -> assert false
                )
              )
              v1
            ,
            Run.opt
              (fun v -> Run.trans_token (Run.matcher_token v))
              v2
            ,
            Run.trans_token (Run.matcher_token v3)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_pair ((kind, body) : mt) : CST.pair =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Str_COLON_value (
            (match v with
            | Seq [v0; v1; v2] ->
                (
                  trans_string_ (Run.matcher_token v0),
                  Run.trans_token (Run.matcher_token v1),
                  trans_value (Run.matcher_token v2)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            (match v with
            | Seq [v0] ->
                (trans_semgrep_ellipsis (Run.matcher_token v0))
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

and trans_value ((kind, body) : mt) : CST.value =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Choice_obj (
            (match v with
            | Alt (0, v) ->
                `Obj (
                  trans_object_ (Run.matcher_token v)
                )
            | Alt (1, v) ->
                `Array (
                  trans_array_ (Run.matcher_token v)
                )
            | Alt (2, v) ->
                `Num (
                  trans_number (Run.matcher_token v)
                )
            | Alt (3, v) ->
                `Str (
                  trans_string_ (Run.matcher_token v)
                )
            | Alt (4, v) ->
                `True (
                  trans_true_ (Run.matcher_token v)
                )
            | Alt (5, v) ->
                `False (
                  trans_false_ (Run.matcher_token v)
                )
            | Alt (6, v) ->
                `Null (
                  trans_null (Run.matcher_token v)
                )
            | _ -> assert false
            )
          )
      | Alt (1, v) ->
          `Semg_ellips (
            trans_semgrep_ellipsis (Run.matcher_token v)
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

let trans_document ((kind, body) : mt) : CST.document =
  match body with
  | Children v ->
      (match v with
      | Alt (0, v) ->
          `Rep_value (
            Run.repeat
              (fun v -> trans_value (Run.matcher_token v))
              v
          )
      | Alt (1, v) ->
          `Pair_opt_COMMA (
            (match v with
            | Seq [v0; v1] ->
                (
                  trans_pair (Run.matcher_token v0),
                  Run.opt
                    (fun v -> Run.trans_token (Run.matcher_token v))
                    v1
                )
            | _ -> assert false
            )
          )
      | _ -> assert false
      )
  | Leaf _ -> assert false

(*
   Costly operation that translates a whole tree or subtree.

   The first pass translates it into a generic tree structure suitable
   to guess which node corresponds to each grammar rule.
   The second pass is a translation into a typed tree where each grammar
   node has its own type.

   This function is called:
   - once on the root of the program after removing extras
     (comments and other nodes that occur anywhere independently from
     the grammar);
   - once of each extra node, resulting in its own independent tree of type
     'extra'.
*)
let translate_tree src node trans_x =
  let matched_tree = Run.match_tree children_regexps src node in
  Option.map trans_x matched_tree


let translate_extra src (node : Tree_sitter_output_t.node) : CST.extra option =
  match node.type_ with
  | "comment" ->
      (match translate_tree src node trans_comment with
      | None -> None
      | Some x -> Some (`Comment (Run.get_loc node, x)))
  | _ -> None

let translate_root src root_node =
  translate_tree src root_node trans_document

let parse_input_tree input_tree =
  let orig_root_node = Tree_sitter_parsing.root input_tree in
  let src = Tree_sitter_parsing.src input_tree in
  let errors = Run.extract_errors src orig_root_node in
  let opt_program, extras =
     Run.translate
       ~extras
       ~translate_root:(translate_root src)
       ~translate_extra:(translate_extra src)
       orig_root_node
  in
  Parsing_result.create src opt_program extras errors

let string ?src_file contents =
  let input_tree = parse_source_string ?src_file contents in
  parse_input_tree input_tree

let file src_file =
  let input_tree = parse_source_file src_file in
  parse_input_tree input_tree

